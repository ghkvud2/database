# 3. 인덱스 튜닝

- SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니라면, 인덱스를 스캔한 후에 반드시 테이블을 엑세스한다. 아래 실행 계획의 'TABLE ACESS BY INDEX ROWID' 라고 표시된 부분이 여기에 해당한다.

```SQL
SQL〉select * from 고객 where 지역 = '서울';
----------------------------------------------------
Execution Plan
0 	SELECT STATEMENT Optimizer=ALL_ROWS
1 0 	TABLE ACCESS BY INDEX ROWID OF '고객' (TABLE)
2 1 		INDEX RANGE SCAN OF '고객_지역_IDX' (INDEX)
```

- 인덱스 리프 노드에서 얻은 ROWID로 테이블에 엑세스한다. 인덱스를 통해 데이터를 찾는 과정을 다시 한 번 살펴보자. 매번 디스크에서 데이터를 읽을 수는 없으니, 버퍼 캐시를 활용하여 데이터를 캐시해 놓는다. 찾고자 하는 데이터가 버퍼 캐시에 없다면 디스크에서 해당 데이터를 버퍼 캐시에 적재한 뒤 데이터를 읽는다. 버퍼 캐시에서 읽을 때는 읽고자 하는 DBA(데이터 파일번호 + 블록번호)를 해시 함수에 입력해서 버킷을 찾은 뒤 버킷의 연결 리스트에 저장된 버퍼 헤더를 찾는다. 그 버퍼 헤더에는 실제 데이터가 저장된 버퍼 블록의 주소 값을 가지고 있다. 

  > 모든 데이터가 캐싱돼 있더라도 테이블 레코드를 찾기 위해 매번 DBA 해싱과 래치 획득 과정을 반복해야 하고, 동시 엑세스가 심할 때는 캐시버퍼 체인 래치와 버퍼  Lock에 대한 경합까지 발생한다. 이처럼 인덱스 ROWID를 이용한 테이블 엑세스는 생각보다 고비용 구조이다.



## 인덱스 클러스터링 팩터

- 클러스터링 팩터는 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미한다. 인덱스는 정렬되어 있는 상태로 유지되지만 실제 데이터도 물리적 디스크의 연속적인 공간에 저장될 것이라는 법은 없다. 클러스터링 팩터가 좋은 컬럼에 생성한 인덱스 검색 효율은 매우 좋다. 

- 인덱스는 무조건 Single Block I/O를 통해 데이터에 엑세스한다고 했는데 클러스터링 팩터가 좋을수록 인덱스 검색 효율이 좋다는 이유는 뭘까? 오라클은 인덱스 ROWID로 테이블을 엑세스할 때, 래치 획득과 해시 체인 스캔 과정을 거쳐 어렵게 찾아간 테이블 블록에 대한 메모리 주소 값을 바로 해제하지 않고 일단 유지하는데, 이를 버퍼 Pinning이라고 부른다. 예를 들어, 첫 번째 인덱스 리프 노드에 접근하여 얻은 ROWID를 가지고 위에서 설명한 일련의 과정을 거쳐 0x1234라는 테이블 블록 주소를 얻어 데이터를 읽었다. 두 번째 인덱스 리프 노드에 접근했더니 첫 번째 노드와 똑같은 같은 블록을 가리킨다면 바로 테이블 블록을 읽을 수 있다. 즉, 인덱스 클러스터링 팩터가 나쁘면 같은 테이블 블록을 여러 번 반복 엑세스하면서 I/O 횟수가 늘어나게 된다.



## 인덱스 손익 분기점

- 인덱스 ROWID를 이용한 테이블 엑세스는 읽어야 할 데이터가 일정량을 넘는 순간, 테이블 풀 스캔보다 성능이 느려진다. Index Range Scan에 의한 테이블 엑세스가 테이블 풀 스캔보다 느려지는 지점을 흔히 '인덱스 손익 분기점'이라고 한다. 인덱스를 이용한 테이블 엑세스가 테이블 풀 스캔보다 더 느려지게 만드는 이유는 아래와 같다.

  1. 테이블 풀 스캔은 시퀀셜 엑세스인 반면, 인덱스 ROWID를 이용한 테이블 엑세스는 랜덤 엑세스 방식이다.
  2. 테이블 풀 스캔은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 엑세스는 Single Block I/O 방식이다.

  

## 인덱스 컬럼 추가
