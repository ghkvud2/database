# 1. SQL 처리 과정과 I/O



## 1.1. SQL 파싱과 최적화

- 사용자로부터 SQL을 전달받으면 SQL Parser가 파싱을 진행한다. SQL 문을 이루는 개별 구성 요소를 분석해서 파싱 트리를 생성하고 문법적 오류가 있는지 체크한다. 그리고 의미상 오류가 없는지 확인한다. 그 다음 단계가 SQL 최적화이고 옵티마이저가 그 역할을 맡는다. 옵티마이저는 데이터 딕셔너리에 미리 수집한 오브젝트 통계정보를 바탕으로 실행 경로를 생성해서 Cost 기반으로 비교한 후 가장 효율적인 하나를 선택한다.

  > *문법적 오류는 잘못된 키워드를 사용했는지, 순서가 바르지 않은지를 확인하는 것이고 의미상 오류는 존재하지 않는 테이블이나 컬럼을 사용하거나 권한이 없는 오브젝트에 접근했는지를 확인하는 것이다.*

- 옵티마이저가 항상 최선의 선택을 하는 것은 아니므로 개발자가 직접 힌트를 사용하여 데이터 엑세스 경로를 바꿀 수 있다. 힌트 사용법은 주석 기호에 '+'를 붙이면 된다.

  ```sql
  SELECT /*+ INDEX(A 고객_PK) */
  	   A.고객명
    FROM 고객 A
   WHERE 고객_ID = '1'
  ```

- 힌트 안에 인자를 나열할 땐 콤마를 사용할 수 있지만 힌트와 힌트 사이에 사용하면 안된다.

  ```sql
  /*+ INDEX(A A_X01) INDEX(B, B_X02) */ -- 모두 유효
  /*+ INDEX(C), FULL(D) */ -- 첫 번째 힌트만 유효
  ```



## 1.2. SQL 공유 및 재사용

- SQL파싱 과정을 거쳐 생성한 SQL을 저장하는 메모리 공간을 라이브러리 캐시라고 한다. 사용자가 SQL문을 전달하면 라이브러리 캐시에 해당 SQL이 존재하는지부터 확인한다. 만약 라이브러리 캐시에 해당 SQL을 찾으면 곧바로 실행 단계로 넘어가는데 이를 `소프트 파싱`이라고하고 라이브러리 캐시에 존재하지 않아 SQL 파싱과 최적화 과정을 거치는 것을 `하드 파싱`이라고 한다. 라이브러리 캐시에서 SQL을 찾기 위해 사용되는 키 값은 `SQL문 그 자체`이므로 의미와 결과는 모두 같더라도 한 글자라도 다르면 다른 SQL로 인식되어 모두 라이브러리 캐시에 저장된다.

  > 통계정보와 다양한 실행 경로를 생성하여 Cost 기반으로 비교하는 SQL 최적화 단계는 비용이 많이 든다. 즉, 같은 SQL문이라면 SQL 최적화 단계는 한 번만 수행하고 다음부터는 공유되는 것이 비용 측면에서 효율적이다.

- 바인드 변수를 사용하지 않는다면 의미적으로는 같은 SQL이라고 할지라도 SQL문 자체가 다르기 때문에 각각의 SQL문이 하드 파싱되어 라이브러리 캐시에 저장될 것이다. 그 대신에 바인드 변수를 사용하게 되면 아래와 같이 단 하나의 SQL문만 저장되어 있을 것이다. 이 SQL에 대한 하드파싱은 최초 한 번만 일어나고, 캐싱된 SQL이 계속해서 공유되어질 것이다.

  ```sql
  SQL> SELECT * FROM EMP WHERE ENMAE = :1
  ```



# 2. 데이터 저장 구조 및 I/O 메커니즘

## 2.1. SQL이 느린 이유

- SQL이 느린 이유는 십중팔구 디스크 입출력때문이다. 프로세스는 CPU를 선점하여 작업을 진행하다가 디스크 입출력이 필요하면 CPU를 반환하고 대기 큐에서 입출력이 끝날 때 까지 기다린다. CPU를 선점하여 계속해서 일해야하는 프로세스가 입출력으로 인해 대기 상태에 빠지니 느릴 수 밖에 없다.



## 2.2. 데이터 베이스 저장구조

> ​	테이블 스페이스 > 세그먼트 > 익세텐트 > 블록

- 잘 모르겠음



## 2.3. 블록 단위 I/O

- 데이터 입출력의 단위는 블록이다. 특정 레코드 하나를 읽고 싶어도 블록을 통째로 읽어야 하고 1바이트짜리 컬럼 하나만 읽더라도 블록을 통째로 읽을 수 밖에 없다. 오라클의 경우 기본적으로 8KB 크기의 블록을 사용하므로 1바이트를 읽더라도 8KB를 읽어야 한다.

  ``` sql
  SQL> show parameter block_size
  SQL> select value from v$parameter where name = 'db_block_size'
  ```
  
  **Q. 100만개의 레코드를 가지는 두 개의 테이블이 있을 때, 검색 속도는 서로 동일할까?**
  - 레코드의 수가 같더라도 컬럼의 수, 컬럼에 저장된 데이터의 크기에 따라 달라질 수 있다. 레코드의 수는 같더라도 한 개의 컬럼을 가진 A테이블과 백 개의 컬럼을 가진 B테이블은 분명히 데이터 크기의 차이가 있을 것이다. B테이블은 데이터를 저장하기 위해 더 많은 공간이 필요할 것이다. 즉, 데이터를 저장하기 위해 더 많은 블록이 사용될 것이고 그만큼 블록I/O가 더 많이 발생할 것이다.
  
  **Q. 100만개의 레코드를 가지고 컬럼 크기와 값도 서로 동일한 두 개의 테이블이 있을 때, 검색 속도는 서로 동일할까?**
  - 클러스터링 팩터(factor)를 고려해야한다. 엑세스하고자 하는 데이터들이 같은 블록에 모여있다면 전체 블록 I/O로 줄어들 것이다.

**클러스터링 팩터**

- 클러스터링 팩터는 데이터가 모여있는 정도라고 해석할 수 있다. 테이블의 검색 조건이 되는 컬럼 값들이 서로 얼마나 모여있느냐에 따라서 조회 성능에 큰 차이가 날 수 있다. 일반적으로 테이블의 검색 조건은 여러 컬럼이 될 수 있는데 특정 컬럼 값을 기준으로 데이터들이 모여 있다면 조건에 그 컬럼에 한해서는 성능이 좋을 수 있으나 다른 조건으로 검색할 경우에는 오히려 성능 저하가 발생할 수 있다.

## 2.4. 시퀀셜 엑세스와 랜덤 엑세스
- 테이블 또는 인덱스 블록을 엑세스하는 방식에는 시퀀셜 엑세스와 랜덤 엑세스가 있다. 시퀀셜 엑세스는 연결된 순서에 따라 차례대로 블록을 읽는 방식이다. 인덱스 리프 블록은 앞뒤 주소를 가리키는 주소 값을 통해 연결되어 있으므로 순차적으로 스캔할 수 있다. 랜덤 엑세스 방식은 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식이다.

**테이블 풀 스캔과 인덱스를 통한 랜덤 엑세스**
- 디스크에서 블록을 읽을 때 한 블록이 아닌 여러 블록을 한 번에 읽는 방식을 Multi Block I/O라하고, 단 하나의 블록만을 읽는 것을 Single Block I/O라고한다. 시퀀셜 엑세스은 블록을 순차적으로 읽기 때문에 Multi Block I/O 방식으로 블록을 읽을 수 있다. 시퀀셜 엑세스의 대표적인 예가 바로 테이블 풀 스캔이다. 반면 인덱스의 경우에는 인덱스 리프 노드가 갖고 있는 ROWID를 통해 테이블 블록에 엑세스하는 방식이다.

**Q. 테이블 풀 스캔을 통한 검색이 빠를까? 인덱스를 통한 검색이 빠를까?**
- 데이터의 양에 따라 다르다. 100만건의 레코드를 갖는 테이블에 대하여 인덱스를 통해 100건의 데이터를 조회하는 것은 매우 빠를 것이다. 하지만 10건이 아닌 검색해야할 데이터의 수가 늘어날 수록 랜덤 엑세스 횟수가 점차 늘어날 것이다. 랜덤 엑세스는 Single Block I/O 방식이기 때문에 정확히 한 블록만 메모리에 적재한다. 반면에 테이블 풀 스캔의 경우 테이블의 모든 블록에 엑세스해야겠지만 Multi Block I/O 방식을 사용하기 때문에 한 번에 많은 양의 데이터를 읽을 수 있어 오히려 조회 성능이 더 좋을 수 있다.

**대용량 데이터 테이블에 대해서 단독 인덱스를 생성해도 될까?**
- 컬럼 도메인 값의 분포도에 따라 단독 인덱스를 생성할지 생각해봐야 한다. 남녀 1:1 비율로 1억명의 회원 정보가 저장된 테이블에 성별 컬럼이 있다고하자. 이때 성별 컬럼을 단독 인덱스로 설정해도 될까? 인덱스를 통해 검색을 한다는 것은 랜덤 엑세스를 통해 데이터를 조회하겠다는 뜻이다. 만약 '성별=남자'인 조건으로 검색을 할 경우 랜덤 엑세스의 대상 블록은 5천만 건이 되기 때문에 성능은 안좋을 수 밖에 없다. 반면, 회원들의 생년월일을 단독 인덱스로 설정했다고 가정해보자. 회원들끼리의 생년월일 분포도는 매우 넓게 퍼져있을 것이므로 '생년월일=19901108'인 조건으로 검색을 했을 때 랜덤 엑세스 대상의 블록 수는 현저히 낮아질 것이다.

## 2.5. 논리적 I/O와 물리적 I/O
- 하드 파싱된 SQL문을 라이브러리 캐시에 저장하여 공유하는 것 외에도 데이터 자체를 공유하기도 한다. 디스크에서 읽은 데이터를 *DB 버퍼 캐시*에 저장해두고 그 다음부터 데이터 블록을 읽을 땐, DB 버퍼 캐시부터 찾는다. 디스크가 아닌 공유 메모리 영역에서 블록을 읽으므로 성능이 향상된다. 논리적 블록 I/O는 버퍼 캐시에서 발생한 총 블록 입출력을 말하고, 물리적 블록 I/O는 디스크에서 발생한 총 블록의 입출력을 뜻한다. SQL 처리 도중 버퍼캐시에서 찾지 못할 때만 디스크를 엑세스하므로 논리적 블록 I/O 중에서 일부를 물리적 I/O한다. SQL을 수행하면서 읽은 총 블록I/O가 논리적 블록 I/O다. 반면에 버퍼 캐시에서 블록을 찾지 못해서 디스크에서 읽은 블록I/O가 물리적 블록I/O다. 물리적 블록 I/O를 통해 읽은 블록은 버퍼 캐시에 저장되므로 첫 번째 실행할 때보다 두 번째 실행할 때 줄어들고, 세 번째 실행할 땐 더 줄어든다. 연속해서 실행하면 버퍼 캐시에서 해당 테이블 블록의 점유율이 높아지기 때문이다.

  > 여기서 중요한 것은 물리적 I/O를 줄일 수 있는 방법은 메모리를 증설하여 버퍼 캐시의 사이즈를 늘릴 수 밖에 없다는 것이다. 즉, 성능을 향상시키기 위해서는 SQL을 튜닝해서 논리적 I/O (읽는 총 블록 개수)를 줄일 수 밖에 없다.

## 2.6 Single Block I/O vs Multiblock I/O

- 버퍼캐시에서 찾지 못한 데이터는 디스크에서 DB 버퍼캐시로 적재하고나서 읽는다. I/O가 발생할 때 한 번에 한 블록씩 요청하기도 하고, 여러 블록씩 요청하기도 한다. 전자를 Singblock I/O라고하며 후자를 Multiblock I/O라고 한다.
- 인덱스를 이용할 때는 기본적으로 인덱스와 테이블 블록 모두 Single block I/O 방식을 사용한다. 인덱스의 루트 블록을 읽을 때, 루트 노드에서 뻗어나가는 브랜치 노드 블록을 읽을 때 마지막 리프 노드를 읽을 때, 리프 노드에 저장된 ROWID를 참조하여 테이블 블록을 읽을 때 모두 Single block I/O 방식을 사용한다. 위에서 설명했듯이 많은 데이터 블록을 읽을 때는 Multiblock I/O가 유리하고 테이블 풀스캔이 이에 해당한다. Multiblock I/O의 블록 크기는 아래 명령어로 확인할 수 있다.

```sql
SQL> show parameter db_file_multiblock_read_count
```

- Multiblock I/O 방식에서 인접한 여러 블록을 읽을 때, 같은 익스텐트에 속한 블록만을 읽는다. 예를 들어, 한 익세텐트에 20개의 블록이 담겨있고 Multiblock I/O 단위가 8이라고 할 때, 세 번째 I/O 단계에서는 4개의 블록만 읽는다는 것이다.
